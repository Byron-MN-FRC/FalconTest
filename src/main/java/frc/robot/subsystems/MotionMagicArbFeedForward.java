package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.*;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;

import edu.wpi.first.wpilibj.Joystick;
import frc.robot.Constants;

public class MotionMagicArbFeedForward {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX falconLeftMaster;
    private WPI_TalonFX falconLeftFollower;
    private WPI_TalonFX falconRightMaster;
    private WPI_TalonFX falconRightFollower;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Joystick _gamepad = null;

    /** Latched values to detect on-press events for buttons and POV */
    private boolean[] _btns = new boolean[Constants.kNumButtonsPlusOne];
    private boolean[] btns = new boolean[Constants.kNumButtonsPlusOne];

    /** Tracking variables */
    boolean _firstCall = false;
    boolean _state = false;

    /** How much smoothing [0,8] to use during MotionMagic */
    int _smoothing;

    
    public MotionMagicArbFeedForward(WPI_TalonFX leftMaster, WPI_TalonFX leftFollower, WPI_TalonFX rightMaster,
            WPI_TalonFX rightFollower, Joystick stick) {
        falconLeftMaster = leftMaster;
        falconLeftFollower = leftFollower;
        falconRightMaster = rightMaster;
        falconRightFollower = rightFollower;
        _gamepad = stick;
        MotorConfig();
    }

    public void MotorConfig() {
        /* Disable all motors */
        falconLeftMaster.set(ControlMode.PercentOutput, 0);
        falconRightMaster.set(ControlMode.PercentOutput, 0);
        falconLeftFollower.set(ControlMode.PercentOutput, 0);
        falconRightFollower.set(ControlMode.PercentOutput, 0);

        /* Factory Default all hardware to prevent unexpected behavior */
        falconLeftMaster.configFactoryDefault();
        falconRightMaster.configFactoryDefault();
        falconLeftFollower.configFactoryDefault();
        falconRightFollower.configFactoryDefault();

        /* Set neutral modes */
        falconLeftMaster.setNeutralMode(NeutralMode.Brake);
        falconRightMaster.setNeutralMode(NeutralMode.Brake);
        falconLeftFollower.setNeutralMode(NeutralMode.Brake);
        falconRightFollower.setNeutralMode(NeutralMode.Brake);

        /* Configure output and sensor direction */
        falconLeftMaster.setInverted(false);
        falconRightMaster.setInverted(true);
        falconLeftFollower.setInverted(false);
        falconRightFollower.setInverted(true);

        //falconLeftMaster.setSensorPhase(true); // ignored on falcons, guarenteed to be in phase
        //falconRightMaster.setSensorPhase(true);// ignored on falcons, guarenteed to be in phase
        

        /** Feedback Sensor Configuration */

        /* Configure the left Talon's selected sensor to a QuadEncoder */
//        falconLeftMaster.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, // Local Feedback Source
//                Constants.PID_PRIMARY, // PID Slot for Source [0, 1]
//                Constants.kTimeoutMs); // Configuration Timeout

        /*
         * Configure the Remote Talon's selected sensor as a remote sensor for the right
         * Talon
         */
//        falconRightMaster.configRemoteFeedbackFilter(falconLeftMaster.getDeviceID(), // Device ID of Source
//                RemoteSensorSource.TalonSRX_SelectedSensor, // Remote Feedback Source
//                Constants.REMOTE_0, // Source number [0, 1]
//                Constants.kTimeoutMs); // Configuration Timeout

        /* Setup Sum signal to be used for Distance */
//        falconRightMaster.configSensorTerm(SensorTerm.Sum0, FeedbackDevice.RemoteSensor0, Constants.kTimeoutMs); // Feedback
                                                                                                                 // Device
                                                                                                                 // of
                                                                                                                 // Remote
                                                                                                                 // Talon
//        falconRightMaster.configSensorTerm(SensorTerm.Sum1, FeedbackDevice.CTRE_MagEncoder_Relative,
//                Constants.kTimeoutMs); // Integrated Encoder of current Talon

        /* Configure Sum [Sum of both QuadEncoders] to be used for Primary PID Index */
//        falconRightMaster.configSelectedFeedbackSensor(FeedbackDevice.SensorSum, Constants.PID_PRIMARY,
//                Constants.kTimeoutMs);

        /* Scale Feedback by 0.5 to half the sum of Distance */
//        falconRightMaster.configSelectedFeedbackCoefficient(0.5, // Coefficient
//                Constants.PID_PRIMARY, // PID Slot of Source
//                Constants.kTimeoutMs); // Configuration Timeout


        /* Set status frame periods to ensure we don't have stale data */
//        falconRightMaster.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, Constants.kTimeoutMs);
//        falconRightMaster.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, Constants.kTimeoutMs);
//        falconLeftMaster.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 5, Constants.kTimeoutMs);

        /* Configure neutral deadband */
//        falconRightMaster.configNeutralDeadband(Constants.kNeutralDeadband, Constants.kTimeoutMs);
//        falconLeftMaster.configNeutralDeadband(Constants.kNeutralDeadband, Constants.kTimeoutMs);

        /* Motion Magic Configurations */
//        falconRightMaster.configMotionAcceleration(2000, Constants.kTimeoutMs);
//        falconRightMaster.configMotionCruiseVelocity(2000, Constants.kTimeoutMs);

        /**
         * Max out the peak output (for all modes). However you can limit the output of
         * a given PID object with configClosedLoopPeakOutput().
         */
//        falconLeftMaster.configPeakOutputForward(+1.0, Constants.kTimeoutMs);
//        falconLeftMaster.configPeakOutputReverse(-1.0, Constants.kTimeoutMs);
//        falconRightMaster.configPeakOutputForward(+1.0, Constants.kTimeoutMs);
//        falconRightMaster.configPeakOutputReverse(-1.0, Constants.kTimeoutMs);

        /* FPID Gains for Motion Magic servo */
//        falconRightMaster.config_kP(Constants.kSlot_Distanc, Constants.kGains_Distanc.kP, Constants.kTimeoutMs);
//        falconRightMaster.config_kI(Constants.kSlot_Distanc, Constants.kGains_Distanc.kI, Constants.kTimeoutMs);
//        falconRightMaster.config_kD(Constants.kSlot_Distanc, Constants.kGains_Distanc.kD, Constants.kTimeoutMs);
//        falconRightMaster.config_kF(Constants.kSlot_Distanc, Constants.kGains_Distanc.kF, Constants.kTimeoutMs);
//        falconRightMaster.config_IntegralZone(Constants.kSlot_Distanc, Constants.kGains_Distanc.kIzone,
//                Constants.kTimeoutMs);
//        falconRightMaster.configClosedLoopPeakOutput(Constants.kSlot_Distanc, Constants.kGains_Distanc.kPeakOutput,
//                Constants.kTimeoutMs);

        /**
         * 1ms per loop. PID loop can be slowed down if need be. For example, - if
         * sensor updates are too slow - sensor deltas are very small per update, so
         * derivative error never gets large enough to be us
         * eful. - sensor movement is
         * very slow causing the derivative error to be near zero.
         */
//        int closedLoopTimeMs = 1;
//        falconRightMaster.configClosedLoopPeriod(0, closedLoopTimeMs, Constants.kTimeoutMs);
//        falconRightMaster.configClosedLoopPeriod(1, closedLoopTimeMs, Constants.kTimeoutMs);

//        falconRightMaster.setStatusFramePeriod(StatusFrameEnhanced.Status_10_Targets, 10);
    }

    /** Deadband 5 percent, used on the gamepad */
    double Deadband(double value) {
        /* Upper deadband */
        if (value >= +0.09)
            return value;

        /* Lower deadband */
        if (value <= -0.09)
            return value;

        /* Outside deadband */
        return 0;
    }


    public void Periodic() {
        /* Gamepad processing */
        double forward = -1 * _gamepad.getY();
        double turn = _gamepad.getTwist();
        forward = Deadband(forward);
        turn = Deadband(turn);

        /* Button processing for state toggle and sensor zeroing */
        getButtons(btns, _gamepad);
        if (btns[2] && !_btns[2]) {
            _state = !_state; // Toggle state
            _firstCall = true; // State change, do first call operation
        } else if (btns[1] && !_btns[1]) {
            zeroSensors(); // Zero sensors
        }
        if (btns[5] && !_btns[5]) {
            _smoothing--; // Decrement smoothing
            if (_smoothing < 0)
                _smoothing = 0; // Cap smoothing
            falconRightMaster.configMotionSCurveStrength(_smoothing);

            System.out.println("Smoothing value is: " + _smoothing);
        }
        if (btns[6] && !_btns[6]) {
            _smoothing++; // Increment smoothing
            if (_smoothing > 8)
                _smoothing = 8; // Cap smoothing
            falconRightMaster.configMotionSCurveStrength(_smoothing);

            System.out.println("Smoothing value is: " + _smoothing);
        }
        System.arraycopy(btns, 0, _btns, 0, Constants.kNumButtonsPlusOne);
        falconLeftFollower.follow(falconLeftMaster);
        falconRightFollower.follow(falconRightMaster);

        if (!_state) {
            if (_firstCall)
                System.out.println("This is Arcade Drive.\n");

            falconLeftMaster.set(ControlMode.PercentOutput, forward, DemandType.ArbitraryFeedForward, +turn);
            falconRightMaster.set(ControlMode.PercentOutput, forward, DemandType.ArbitraryFeedForward, -turn);
        } else {
            if (_firstCall) {
                System.out.println("This is Motion Magic with an Arbitrary Feed Forward.");
                System.out.println("Servo [-6, 6] rotations while also having to ability to add a feed forward");
                zeroSensors();

                /* Determine which slot affects which PID */
                falconRightMaster.selectProfileSlot(Constants.kSlot_Distanc, Constants.PID_PRIMARY);
            }

            /* calculate targets from gamepad inputs */
            double target_sensorUnits = forward * Constants.kSensorUnitsPerRotation * Constants.kRotationsToTravel;
            double feedFwdTerm = turn * 0.25; // Percent to add to Closed Loop Output

            falconRightMaster.set(ControlMode.MotionMagic, target_sensorUnits, DemandType.ArbitraryFeedForward,
                    feedFwdTerm);
            falconLeftMaster.follow(falconRightMaster);
            
        }
    }

    /** Gets all buttons from gamepad */
    void getButtons(boolean[] btns, Joystick gamepad) {
        for (int i = 1; i < Constants.kNumButtonsPlusOne; ++i) {
            btns[i] = gamepad.getRawButton(i);
        }
    }

    void zeroSensors() {
        falconLeftMaster.getSensorCollection().setIntegratedSensorPosition(0, Constants.kTimeoutMs);
        falconRightMaster.getSensorCollection().setIntegratedSensorPosition(0, Constants.kTimeoutMs);
        System.out.println("[Quadrature Encoders] All sensors are zeroed.\n");
    }

}